<template>
  <div class="col-span-full xl:col-span-12 bg-white dark:bg-gray-800 shadow-sm rounded-xl mt-4">
    
    <!-- Ï†ÑÎ†•Îüâ & Î∂ÄÌïòÏú® Ï∂îÏù¥ Ïπ¥Îìú -->
    <div class="relative col-span-full xl:col-span-12 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700/60 shadow-sm rounded-b-lg mb-4">
      <div class="absolute top-0 left-0 right-0 h-0.5 bg-cyan-500" aria-hidden="true"></div>
      <div class="px-5 pt-5 pb-6 border-b border-gray-200 dark:border-gray-700/60">
        <header class="flex items-center mb-2">
          <div class="w-6 h-6 rounded-full shrink-0 bg-cyan-500 mr-3">
            <svg class="w-6 h-6 fill-current text-white" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" fill="currentColor"/>
            </svg>
          </div>
          <h3 class="text-lg text-gray-800 dark:text-gray-100 font-semibold">
            {{ t(`report.cardTitle.Energy2`)}} 
          </h3>

        </header>
      </div>
      <div class="px-4 py-3 space-y-2">
        <!-- Ïù¥Ï§ë YÏ∂ï Ï∞®Ìä∏ -->
        <div class="dual-axis-section">

          <!--Ï∞®Ìä∏ -->
          <div ref="dualAxisChart" class="dual-axis-chart"></div>

          <!--info card -->
          <div class="chart-info">
            <div class="info-card">
              <span class="info-label">{{ t(`report.cardContext.averageLoadRate`)}} </span>
              <span class="info-value">{{ averageLoadRate.toFixed(1) }}%</span>
            </div>
            <div class="info-card">
              <span class="info-label">{{ t(`report.cardContext.maxLoadRate`)}} </span>
              <span class="info-value">{{ maxLoadRate.toFixed(1) }}%</span>
            </div>
            <div class="info-card">
              <span class="info-label">{{ t(`report.cardContext.overloadCount`)}} </span>
              <span class="info-value" :class="{ 'text-red-600 dark:text-red-400': overloadCount > 0 }">
                {{ overloadCount }}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Î∂ÄÌïòÏú® Ìå®ÌÑ¥ ÌûàÌä∏Îßµ & Î∂ÑÌè¨ ÌÜµÍ≥Ñ Ïπ¥Îìú -->
    <div class="relative col-span-full xl:col-span-12 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700/60 shadow-sm rounded-b-lg">
      <div class="absolute top-0 left-0 right-0 h-0.5 bg-orange-500" aria-hidden="true"></div>
      <div class="px-5 pt-5 pb-6 border-b border-gray-200 dark:border-gray-700/60">
        <header class="flex items-center mb-2">
          <div class="w-6 h-6 rounded-full shrink-0 bg-orange-500 mr-3">
            <svg class="w-6 h-6 fill-current text-white" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 3h18v4H3V3zm0 6h18v2H3V9zm0 4h18v2H3v-2zm0 4h18v4H3v-4z" fill="currentColor"/>
            </svg>
          </div>
          <h3 class="text-lg text-gray-800 dark:text-gray-100 font-semibold">
            {{ t(`report.cardTitle.LoadPatternAnalysis`) }}
          </h3>
   
        </header>
      </div>
      <div class="px-4 py-3 space-y-4">
        <!-- Î°úÎî© ÏÉÅÌÉú -->
        <div v-if="heatmapLoading" class="text-center py-8">
          <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-orange-500"></div>
          <p class="mt-2 text-gray-500">ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...</p>
        </div>

        <!-- ÌûàÌä∏Îßµ Ï∞®Ìä∏ -->
        <div v-else class="heatmap-section">
          <div ref="heatmapChart" class="heatmap-chart"></div>
        </div>

        <!-- ‚úÖ Ïã§Ï†ú API Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Î∂ÑÌè¨ ÌÜµÍ≥Ñ -->
        <div v-if="!heatmapLoading" class="heatmap-stats-section">
          <h4 class="stats-title text-sm font-semibold text-gray-800 dark:text-gray-200 mb-3">{{ t(`report.cardTitle.weeklyLoadDistribution`) }}</h4>
          <div class="load-stats">
            <div class="stat-card light">
              <div class="stat-header">
                <h4>{{ t(`report.cardContext.lightLoadHours`) }}</h4>
                <span class="stat-icon">üü¢</span>
              </div>
              <span class="stat-value">{{ apiHeatmapDistribution.light }}%</span>
              <span class="stat-desc">0-50% {{ t(`report.cardContext.loadRate`) }}</span>
            </div>
            <div class="stat-card medium">
              <div class="stat-header">
                <h4>{{ t(`report.cardContext.mediumLoadHours`) }}</h4>
                <span class="stat-icon">üü°</span>
              </div>
              <span class="stat-value">{{ apiHeatmapDistribution.medium }}%</span>
              <span class="stat-desc">50-80% {{ t(`report.cardContext.loadRate`) }}</span>
            </div>
            <div class="stat-card high">
              <div class="stat-header">
                <h4>{{ t(`report.cardContext.heavyLoadHours`) }}</h4>
                <span class="stat-icon">üü†</span>
              </div>
              <span class="stat-value">{{ apiHeatmapDistribution.high }}%</span>
              <span class="stat-desc">80-100% {{ t(`report.cardContext.loadRate`) }}</span>
            </div>
            <div class="stat-card overload">
              <div class="stat-header">
                <h4>{{ t(`report.cardContext.overloadHours`) }}</h4>
                <span class="stat-icon">üî¥</span>
              </div>
              <span class="stat-value warning">{{ apiHeatmapDistribution.overload }}%</span>
              <span class="stat-desc">100% {{ t(`report.cardContext.overload`) }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted, computed } from 'vue'
import * as echarts from 'echarts'
import { useI18n } from 'vue-i18n'
import { useReportData } from "@/composables/ReportDict";
import dayjs from 'dayjs'

export default {
  name: 'PowerLoadAnalysis',
  props:{
    channel:{
        type: String,
        default:''
      }
  },
  setup(props) {
    // Î∞òÏùëÌòï Îç∞Ïù¥ÌÑ∞
    const { t } = useI18n();
    const {
        reportData,
        getLoadFactorCalculated,
        getHeatmapLoadFactorData,
        loadEnergyHourlyData,
        } = useReportData();
    const selectedTimeRange = ref('24h')
    const channel = ref(props.channel);
    const dualAxisChart = ref(null)
    const heatmapChart = ref(null)
    const heatmapLoading = ref(false)

    // ‚úÖ Ïã§Ï†ú API Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå
    const apiHeatmapData = ref([])
    const apiHeatmapStats = ref({})

    let dualAxisChartInstance = null
    let heatmapChartInstance = null

    // ‚úÖ reportDict.jsÏùò Ìï®ÏàòÎ•º ÏÇ¨Ïö©Ìï¥ÏÑú ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    const loadHeatmapData = async () => {
      heatmapLoading.value = true;
      try {
        //console.log('ÌûàÌä∏Îßµ API Îç∞Ïù¥ÌÑ∞ Î°úÎî© ÏãúÏûë:', channel.value);
        
        const response = await getHeatmapLoadFactorData(channel.value, 4);
        
        //console.log('ÌûàÌä∏Îßµ API ÏùëÎãµ:', response);
        
        if (response && response.success) {
          apiHeatmapData.value = response.heatmapData || [];
          apiHeatmapStats.value = response.distribution || {};
          
          //console.log('ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞ Í∞úÏàò:', apiHeatmapData.value.length);
          //console.log('ÌûàÌä∏Îßµ ÌÜµÍ≥Ñ:', apiHeatmapStats.value);
          
          if (heatmapChartInstance && apiHeatmapData.value.length > 0) {
            createApiHeatmapChart();
          }
          
          setTimeout(() => {
            //console.log('3Ï¥à ÌõÑ Í∞ïÏ†ú ÌûàÌä∏Îßµ ÏÉùÏÑ± ÏãúÎèÑ');
            forceCreateHeatmap();
          }, 3000);
        } else {
          console.error('ÌûàÌä∏Îßµ API Ïã§Ìå®:', response?.message);
        }
      } catch (error) {
        console.error('ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®:', error);
      } finally {
        heatmapLoading.value = false;
      }
    }

    const forceCreateHeatmap = () => {
      console.log('=== Í∞ïÏ†ú ÌûàÌä∏Îßµ ÏÉùÏÑ± ÏãúÎèÑ ===');
      console.log('heatmapChart DOM ÏöîÏÜå:', heatmapChart.value);
      
      if (!heatmapChart.value) {
        console.error('heatmapChart DOM ÏöîÏÜåÍ∞Ä ÏóÜÏùå!');
        return;
      }
      
      if (heatmapChartInstance) {
        //console.log('Í∏∞Ï°¥ Ï∞®Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ Ìï¥Ï†ú');
        heatmapChartInstance.dispose();
      }
      
      //console.log('ÏÉàÎ°úÏö¥ ÌûàÌä∏Îßµ Ï∞®Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±');
      heatmapChartInstance = echarts.init(heatmapChart.value);
      
      if (apiHeatmapData.value.length > 0) {
        //console.log('API Îç∞Ïù¥ÌÑ∞Î°ú Ï∞®Ìä∏ ÏÉùÏÑ±');
        createApiHeatmapChart();
      } else {
        //console.log('ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞Î°ú Ï∞®Ìä∏ ÏÉùÏÑ±');
        createTestHeatmap();
      }
    }

    const createTestHeatmap = () => {
      //console.log('ÌÖåÏä§Ìä∏ ÌûàÌä∏Îßµ ÏÉùÏÑ±');
      
      const days = ['Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†', 'Ïùº'];
      const hours = Array.from({length: 24}, (_, i) => i.toString().padStart(2, '0'));
      
      const testData = [];
      for (let d = 0; d < 7; d++) {
        for (let h = 0; h < 24; h++) {
          testData.push([h, d, Math.random() * 10]);
        }
      }
      
      const option = {
        title: { text: 'ÌÖåÏä§Ìä∏ ÌûàÌä∏Îßµ', left: 'center' },
        tooltip: {
          position: 'top',
          formatter: function (params) {
            return `${days[params.data[1]]} ${hours[params.data[0]]}:00<br/>Í∞í: ${params.data[2].toFixed(1)}%`;
          }
        },
        grid: { height: '60%', top: '10%' },
        xAxis: {
          type: 'category',
          data: hours,
          splitArea: { show: true }
        },
        yAxis: { 
          type: 'category', 
          data: days, 
          splitArea: { show: true } 
        },
        visualMap: {
          min: 0,
          max: 10,
          calculable: true,
          orient: 'horizontal',
          left: 'center',
          bottom: '5%',
          inRange: {
            color: ['#f7fbff', '#08306b']
          }
        },
        series: [{
          name: 'ÌÖåÏä§Ìä∏',
          type: 'heatmap',
          data: testData,
          label: { show: false },
          itemStyle: {
            borderWidth: 1,
            borderColor: '#fff'
          }
        }]
      };
      
      try {
        heatmapChartInstance.setOption(option);
        //console.log('‚úÖ ÌÖåÏä§Ìä∏ ÌûàÌä∏Îßµ ÏÉùÏÑ± ÏÑ±Í≥µ');
      } catch (error) {
        console.error('‚ùå ÌÖåÏä§Ìä∏ ÌûàÌä∏Îßµ ÏÉùÏÑ± Ïã§Ìå®:', error);
      }
    }
    
    const apiHeatmapDistribution = computed(() => {
      if (!apiHeatmapStats.value || Object.keys(apiHeatmapStats.value).length === 0) {
        return { light: 0, medium: 0, high: 0, overload: 0 };
      }

      const total = apiHeatmapStats.value.light + apiHeatmapStats.value.medium + 
                   apiHeatmapStats.value.high + apiHeatmapStats.value.overload;
      
      if (total === 0) {
        return { light: 0, medium: 0, high: 0, overload: 0 };
      }

      return {
        light: Math.round((apiHeatmapStats.value.light / total) * 100),
        medium: Math.round((apiHeatmapStats.value.medium / total) * 100),
        high: Math.round((apiHeatmapStats.value.high / total) * 100),
        overload: Math.round((apiHeatmapStats.value.overload / total) * 100)
      };
    })

    const createApiHeatmapChart = () => {
      if (apiHeatmapData.value.length === 0) {
        console.warn('ÌûàÌä∏Îßµ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
        return;
      }
      
      //console.log('ÌûàÌä∏Îßµ Ï∞®Ìä∏ ÏÉùÏÑ± ÏãúÏûë, Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥:', apiHeatmapData.value.length);
      //console.log('Ï∞®Ìä∏Ïö© Îç∞Ïù¥ÌÑ∞ ÏÉòÌîå:', apiHeatmapData.value.slice(0, 5));
      
      const days = [
        t('report.cardContext.days.mon'),
        t('report.cardContext.days.tue'),
        t('report.cardContext.days.wed'),
        t('report.cardContext.days.thu'),
        t('report.cardContext.days.fri'),
        t('report.cardContext.days.sat'),
        t('report.cardContext.days.sun')
      ];
      
      const hours = Array.from({length: 24}, (_, i) => i.toString().padStart(2, '0'));
      
      let chartData = [];
      
      if (apiHeatmapData.value.length > 0 && Array.isArray(apiHeatmapData.value[0]) && apiHeatmapData.value[0].length === 3) {
        //console.log('Îç∞Ïù¥ÌÑ∞Í∞Ä Ïù¥ÎØ∏ [hour, day, value] ÌòïÏãùÏûÖÎãàÎã§.');
        chartData = apiHeatmapData.value;
      } else {
        //console.log('Îç∞Ïù¥ÌÑ∞ ÌòïÏãùÏùÑ [hour, day, value]Î°ú Î≥ÄÌôòÌï©ÎãàÎã§.');
        chartData = apiHeatmapData.value.map(item => {
          if (Array.isArray(item)) {
            return item;
          } else if (typeof item === 'object') {
            return [item.hour || 0, item.day_of_week || 0, item.load_factor_percent || 0];
          } else {
            return [0, 0, 0];
          }
        });
      }
      
      //console.log('Î≥ÄÌôòÎêú Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÉòÌîå:', chartData.slice(0, 5));
      
      const values = chartData.map(item => item[2] || 0);
      const maxValue = Math.max(...values, 100);
      const minValue = Math.min(...values.filter(v => v > 0), 0);
      
      //console.log('Í∞í Î≤îÏúÑ:', { min: minValue, max: maxValue });
      
      const option = {
          grid: {
          left: '10%',     // ÏôºÏ™Ω Ïó¨Î∞± Ï¶ùÍ∞Ä (5% ‚Üí 10%)
          right: '10%',    // Ïò§Î•∏Ï™Ω Ïó¨Î∞±ÎèÑ Í∑†ÌòïÏûàÍ≤å Ï°∞Ï†ï
          top: '12%',      
          bottom: '10%',   
          containLabel: true  // ÎùºÎ≤®Ïù¥ ÏûòÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù ÏûêÎèô Ï°∞Ï†ï
        },
        tooltip: {
          position: 'top',
          formatter: function (params) {
            const hour = hours[params.data[0]] || '00';
            const day = days[params.data[1]] || 'Ïïå Ïàò ÏóÜÏùå';
            const value = params.data[2] || 0;
            return `${day} ${hour}:00<br/>Î∂ÄÌïòÏú®: ${value.toFixed(1)}%`;
          }
        },
        grid: { height: '50%', top: '10%' },
        xAxis: {
          type: 'category',
          data: hours,
          splitArea: { show: true },
          axisLabel: { 
            formatter: function (value) { 
              const hourNum = parseInt(value);
              return hourNum % 2 === 0 ? value + ':00' : '';
            }
          }
        },
        yAxis: { 
          type: 'category', 
          data: days, 
          splitArea: { show: true } 
        },
        visualMap: {
          min: 0,
          max: Math.max(maxValue * 1.2, 10),
          calculable: true,
          orient: 'horizontal',
          left: 'center',
          bottom: '15%',
          inRange: {
            color: [
              '#22c55e', '#84cc16', '#a3e635', '#bef264', '#facc15', 
              '#fbbf24', '#f59e0b', '#f97316', '#ef4444', '#dc2626'
            ]
          },
          text: ['ÎÜíÏùå', 'ÎÇÆÏùå'],
          textStyle: {
            color: '#333',
            fontSize: 12
          }
        },
        series: [{
          name: 'Î∂ÄÌïòÏú®',
          type: 'heatmap',
          data: chartData,
          label: { 
            show: false 
          },
          itemStyle: {
            borderWidth: 0.5,
            borderColor: '#fff'
          },
          emphasis: { 
            itemStyle: { 
              shadowBlur: 10, 
              shadowColor: 'rgba(0, 0, 0, 0.5)',
              borderWidth: 2,
              borderColor: '#333'
            } 
          }
        }]
      }
      
     
      heatmapChartInstance.setOption(option, true);
    }

    // ‚úÖ ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (fallbackÏö©)
    const generateTimeSeriesData = (timeRange) => {
      const now = new Date()
      const dataPoints = timeRange === '24h' ? 24 : timeRange === '7d' ? 168 : 720
      const interval = timeRange === '24h' ? 1 : timeRange === '7d' ? 1 : 1
      
      const data = []
      for (let i = dataPoints - 1; i >= 0; i--) {
        const time = new Date(now.getTime() - i * interval * 60 * 60 * 1000)
        const hour = time.getHours()
        const dayOfWeek = time.getDay()
        
        data.push({
          time: time.toISOString(),
          loadRate: 0,
          powerConsumption: 0,
          hour: hour,
          dayOfWeek: dayOfWeek
        })
      }
      
      return data
    }

    const timeSeriesData = ref(generateTimeSeriesData('24h'))

    // ‚úÖ Ïã§Ï†ú API Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò computed ÏÜçÏÑ±Îì§
    const averageLoadRate = computed(() => {
      if (reportData.loadrateData && Array.isArray(reportData.loadrateData) && reportData.loadrateData.length > 0) {
        const sum = reportData.loadrateData.reduce((acc, item) => acc + (item.load_factor_percent  || 0), 0);
        return sum / reportData.loadrateData.length;
      }
      
      const sum = timeSeriesData.value.reduce((acc, item) => acc + item.load_factor_percent , 0);
      return sum / timeSeriesData.value.length;
    });

    const maxLoadRate = computed(() => {
      if (reportData.loadrateData && Array.isArray(reportData.loadrateData) && reportData.loadrateData.length > 0) {
        return Math.max(...reportData.loadrateData.map(item => item.load_factor_percent  || 0));
      }
      
      return Math.max(...timeSeriesData.value.map(item => item.load_factor_percent ));
    });

    const overloadCount = computed(() => {
      if (reportData.loadrateData && Array.isArray(reportData.loadrateData) && reportData.loadrateData.length > 0) {
        return reportData.loadrateData.filter(item => (item.load_factor_percent  || 0) > 100).length;
      }
      
      return timeSeriesData.value.filter(item => item.load_factor_percent  > 100).length;
    });

const createDualAxisChart = () => {
  //console.log('=== createDualAxisChart Ïã§Ìñâ ===');
  //console.log('reportData.energyHourlyData:', reportData.energyHourlyData);
  //console.log('reportData.loadrateData!!!!!!!!!!:', reportData.loadrateData);

  let times = [];
  let powerData = [];
  let loadData = [];
  
  // ‚úÖ Ïã§Ï†ú Ï†ÑÎ†•Îüâ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
  if (reportData.energyHourlyData && Array.isArray(reportData.energyHourlyData) && reportData.energyHourlyData.length > 0) {
    //console.log('Ïã§Ï†ú Ï†ÑÎ†•Îüâ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
    
    const now = dayjs();
    const currentHour = now.hour();
    
    const powerDataMap = {};
    reportData.energyHourlyData.forEach((item, index) => {
 
      
      if (item?.hour !== undefined && item?.value !== undefined) {
        const hourLabel = `${item.hour.toString().padStart(2, '0')}:00`;
        const parsedValue = parseFloat(item.value);
        powerDataMap[hourLabel] = parsedValue;
        
        //console.log(`Îß§Ìïë: ${hourLabel} -> ${parsedValue} (ÏõêÎ≥∏: ${item.value})`);
      }
    });
    
    for (let i = 0; i <= currentHour; i++) {
      const hourLabel = `${i.toString().padStart(2, '0')}:00`;
      times.push(hourLabel);
      const value = powerDataMap[hourLabel] || 0;
      powerData.push(value);
      

    }
    
    //console.log('Ïã§Ï†ú Ï†ÑÎ†•Îüâ times:', times);
    //console.log('Ïã§Ï†ú Ï†ÑÎ†•Îüâ data:', powerData);
  } else {
    //console.log('Ï†ÑÎ†•Îüâ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥ÏÑú ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
    times = timeSeriesData.value.map(item => {
      const time = new Date(item.time);
      return time.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
    });
    powerData = timeSeriesData.value.map(() => 0); // ‚úÖ Î™®Îì† Í∞íÏùÑ 0ÏúºÎ°ú Î≥ÄÍ≤Ω
  }

  // ‚úÖ Ïã§Ï†ú Î∂ÄÌïòÏú® Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
  if (reportData.loadrateData && Array.isArray(reportData.loadrateData) && reportData.loadrateData.length > 0) {
    //console.log('Ïã§Ï†ú Î∂ÄÌïòÏú® Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
    
    const loadDataMap = {};
    reportData.loadrateData.forEach(item => {
      if (item?.hour !== undefined && item?.load_factor_percent  !== undefined) {
        const hourLabel = `${item.hour.toString().padStart(2, '0')}:00`;
        loadDataMap[hourLabel] = parseFloat(item.load_factor_percent ) || 0;
      }
    });
    
    loadData = times.map(time => loadDataMap[time] || 0);
    
    console.log('Ïã§Ï†ú Î∂ÄÌïòÏú® data:', loadData);
  } else {
    //console.log('Î∂ÄÌïòÏú® Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥ÏÑú ÎçîÎØ∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
    if (reportData.energyHourlyData && Array.isArray(reportData.energyHourlyData)) {
      loadData = times.map(() => 0); // ‚úÖ Î™®Îì† Í∞íÏùÑ 0ÏúºÎ°ú Î≥ÄÍ≤Ω
    } else {
      loadData = timeSeriesData.value.map(() => 0); // ‚úÖ Î™®Îì† Í∞íÏùÑ 0ÏúºÎ°ú Î≥ÄÍ≤Ω
    }
  }

  //console.log('ÏµúÏ¢Ö Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞:');
  //console.log('times:', times);
  //console.log('powerData:', powerData);
  //console.log('loadData:', loadData);

  // ‚úÖ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Í∞í Î≤îÏúÑ Í≥ÑÏÇ∞ (ÏàòÏ†ïÎêú Î≤ÑÏ†Ñ)
  const powerValues = powerData.filter(val => !isNaN(val) && val > 0);
  const loadValues = loadData.filter(val => !isNaN(val) && val > 0);
  
  const maxPowerValue = powerValues.length > 0 ? Math.max(...powerValues) : 0.01;
  const maxLoadValue = loadValues.length > 0 ? Math.max(...loadValues) : 10;
  
  // ‚úÖ YÏ∂ï Î≤îÏúÑÎ•º ÍπîÎÅîÌïú Í∞íÏúºÎ°ú Í≥ÑÏÇ∞
  const powerAxisMax = maxPowerValue > 0 ? 
    Math.ceil(maxPowerValue * 1.3 * 1000) / 1000 : // ÏÜåÏàòÏ†ê 3ÏûêÎ¶¨ÍπåÏßÄ Ïò¨Î¶º
    0.01;
  const loadAxisMax = Math.ceil(Math.max(maxLoadValue * 1.3, 10));
  
  //console.log('Ï†ÑÎ†•Îüâ ÏµúÎåÄÍ∞í:', maxPowerValue, '-> YÏ∂ï ÏµúÎåÄÍ∞í:', powerAxisMax);
  //console.log('Î∂ÄÌïòÏú® ÏµúÎåÄÍ∞í:', maxLoadValue, '-> YÏ∂ï ÏµúÎåÄÍ∞í:', loadAxisMax);

  const option = {
    grid: {
      left: '1%',     // ÏôºÏ™Ω Ïó¨Î∞± Ï¶ùÍ∞Ä (5% ‚Üí 10%)
      right: '1%',    // Ïò§Î•∏Ï™Ω Ïó¨Î∞±ÎèÑ Í∑†ÌòïÏûàÍ≤å Ï°∞Ï†ï
      top: '12%',      
      bottom: '10%',   
      containLabel: true  // ÎùºÎ≤®Ïù¥ ÏûòÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù ÏûêÎèô Ï°∞Ï†ï
    },
    tooltip: {
      trigger: 'axis',
      axisPointer: { type: 'cross', crossStyle: { color: '#999' } },
      formatter: function (params) {
        let result = params[0].axisValueLabel + '<br/>';
        params.forEach(function (item) {
          if (item.seriesName === 'Ï†ÑÎ†•Îüâ') {
            result += item.marker + item.seriesName + ': ' + item.value + ' kWh<br/>';
          } else {
            result += item.marker + item.seriesName + ': ' + item.value + '%<br/>';
          }
        });
        return result;
      }
    },
    legend: { 
      data: ['Ï†ÑÎ†•Îüâ', 'Î∂ÄÌïòÏú®'],
      top: '2%',  // ‚úÖ Î≤îÎ°ÄÎ•º ÏúÑÎ°ú Ïò¨Î†§ÏÑú Í≥µÍ∞Ñ Ï†àÏïΩ
      textStyle: { fontSize: 12 }
    },
    xAxis: [{ 
      type: 'category', 
      data: times,
      boundaryGap: false, // ‚úÖ Ïπ¥ÌÖåÍ≥†Î¶¨ ÏñëÏ™Ω Ïó¨Î∞± Ï†úÍ±∞
      axisLabel: {
        formatter: function (value) {
          if (times.length > 20) {
            const hourNum = parseInt(value.split(':')[0]);
            return hourNum % 2 === 0 ? value : '';
          }
          return value;
        },
        rotate: times.length > 20 ? 45 : 0
      }
    }],
    yAxis: [
      {
        type: 'value',
        name: 'Ï†ÑÎ†•Îüâ(kWh)',
        position: 'left',
        axisLabel: { 
          formatter: function(value) {
            // 0Ïù¥Î©¥ 0, ÏïÑÎãàÎ©¥ ÏÜåÏàòÏ†ê 3ÏûêÎ¶¨ÍπåÏßÄ ÌëúÏãú
            return value === 0 ? '0' : value.toFixed(3);
          },
          margin: 55
        },
        splitLine: { show: true, lineStyle: { type: 'dashed', color: '#e0e0e0' } },
        min: 0,
        max: powerAxisMax,
        interval: powerAxisMax / 5 // 5Í∞ú Íµ¨Í∞ÑÏúºÎ°ú ÎÇòÎàÑÍ∏∞
      },
      {
        type: 'value',
        name: 'Î∂ÄÌïòÏú®(%)',
        position: 'right',
        axisLabel: { 
          formatter: function(value) {
            // 0Ïù¥Î©¥ 0, ÏïÑÎãàÎ©¥ ÏÜåÏàòÏ†ê 3ÏûêÎ¶¨ÍπåÏßÄ ÌëúÏãú
            return value === 0 ? '0' : value.toFixed(3);
          },
          fontSize: 10,  // ‚úÖ Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï§ÑÏó¨ÏÑú Í≥µÍ∞Ñ Ï†àÏïΩ
          margin: 55      // ‚úÖ Ï∂ïÍ≥º ÎùºÎ≤® ÏÇ¨Ïù¥ Í∞ÑÍ≤© Ï§ÑÏûÑ
        },
        min: 0,
        max: loadAxisMax,
        splitLine: { show: false }
      }
    ],
    series: [
      {
        name: 'Ï†ÑÎ†•Îüâ',
        type: 'bar',
        yAxisIndex: 0,
        data: powerData,
        itemStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: '#83bff6' },
            { offset: 0.5, color: '#188df0' },
            { offset: 1, color: '#188df0' }
          ])
        }
      },
      {
        name: 'Î∂ÄÌïòÏú®',
        type: 'line',
        yAxisIndex: 1,
        data: loadData,
        lineStyle: { width: 3, color: '#ff6b6b' },
        itemStyle: { color: '#ff6b6b' },
        areaStyle: { opacity: 0.1, color: '#ff6b6b' },
        smooth: true
      }
    ]
  };
  
  //console.log('ECharts ÏòµÏÖò ÏÑ§Ï†ï ÏôÑÎ£å');
  dualAxisChartInstance.setOption(option);
};
    const refreshData = () => {
      loadHeatmapData();
    }

    // ‚úÖ ÎùºÏù¥ÌîÑÏÇ¨Ïù¥ÌÅ¥ ÌõÖ - Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÌõÑ Ï∞®Ìä∏ ÏÉùÏÑ±
    onMounted(async () => {
      //console.log('PowerLoadAnalysis Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏Îê®, channel:', channel.value);

      if (heatmapChart.value.hasAttribute('_echarts_instance_')) {
        const oldInstance = echarts.getInstanceByDom(heatmapChart.value);
        if (oldInstance) {
          oldInstance.dispose();
          //console.log('Í∏∞Ï°¥ ÌûàÌä∏Îßµ Ïù∏Ïä§ÌÑ¥Ïä§ Ï†úÍ±∞Îê®');
        }
      }
      
      dualAxisChartInstance = echarts.init(dualAxisChart.value);
      heatmapChartInstance = echarts.init(heatmapChart.value);
      
      try {
        //console.log('API Îç∞Ïù¥ÌÑ∞ Î°úÎî© ÏãúÏûë...');
        
        await Promise.all([
          loadEnergyHourlyData(channel.value),
          getLoadFactorCalculated(channel.value)
        ]);
        
        //console.log('API Îç∞Ïù¥ÌÑ∞ Î°úÎî© ÏôÑÎ£å');
        //console.log('energyHourlyData:', reportData.energyHourlyData);
        //console.log('loadrateData:', reportData.loadrateData);
        
        createDualAxisChart();
        
      } catch (error) {
        console.error('API Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®:', error);
        createDualAxisChart();
      }
      
      await loadHeatmapData();
      
      window.addEventListener('resize', () => {
        dualAxisChartInstance?.resize();
        heatmapChartInstance?.resize();
      });
    });

    onUnmounted(() => {
      dualAxisChartInstance?.dispose()
      heatmapChartInstance?.dispose()
      window.removeEventListener('resize', () => {})
    })

    return {
      selectedTimeRange,
      dualAxisChart,
      heatmapChart,
      heatmapLoading,
      averageLoadRate,
      maxLoadRate,
      overloadCount,
      apiHeatmapDistribution,
      refreshData,
      t,
      getLoadFactorCalculated,
      channel,
    }
  }
}
</script>

<style scoped>
/* Ï∞®Ìä∏ ÏòÅÏó≠ */
.dual-axis-chart {
  @apply h-80 w-full;
}

.heatmap-chart {
  @apply h-56 w-full;
}

/* ÌûàÌä∏Îßµ ÌÜµÍ≥Ñ ÏÑπÏÖò */
.heatmap-stats-section {
  @apply pt-3 border-t border-gray-200 dark:border-gray-700;
}

.stats-title {
  @apply text-sm font-semibold text-gray-800 dark:text-gray-200 mb-3;
}

.chart-info {
  @apply flex justify-around mt-3 pt-3 border-t border-gray-200 dark:border-gray-700;
}

.info-card {
  @apply text-center;
}

.info-label {
  @apply block text-sm text-gray-500 dark:text-gray-400 mb-1;
}

.info-value {
  @apply text-lg font-bold text-gray-900 dark:text-gray-100;
}

/* ÌÜµÍ≥Ñ Ïπ¥ÎìúÎì§ - ÌûàÌä∏Îßµ ÏÉâÏÉÅ Îß§Ïπ≠ */
.load-stats {
  @apply grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3;
}

.stat-card {
  @apply bg-gray-50 dark:bg-gray-700/50 p-3 rounded-lg text-center;
  @apply border-l-4;
}

.stat-card.light {
  @apply border-l-8;
  border-left-color: #22c55e;
  @apply bg-gradient-to-br from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20;
}

.stat-card.medium {
  @apply border-l-8;
  border-left-color: #eab308;
  @apply bg-gradient-to-br from-yellow-50 to-amber-50 dark:from-yellow-900/20 dark:to-amber-900/20;
}

.stat-card.high {
  @apply border-l-8;
  border-left-color: #f97316;
  @apply bg-gradient-to-br from-orange-50 to-red-50 dark:from-orange-900/20 dark:to-red-900/20;
}

.stat-card.overload {
  @apply border-l-8;
  border-left-color: #dc2626;
  @apply bg-gradient-to-br from-red-50 to-pink-50 dark:from-red-900/20 dark:to-pink-900/20;
}

.stat-header {
  @apply flex justify-between items-center mb-2;
}

.stat-card h4 {
  @apply text-gray-700 dark:text-gray-300 text-sm font-semibold;
}

.stat-icon {
  @apply text-xl;
}

.stat-card.light .stat-icon {
  color: #22c55e;
}

.stat-card.medium .stat-icon {
  color: #eab308;
}

.stat-card.high .stat-icon {
  color: #f97316;
}

.stat-card.overload .stat-icon {
  color: #dc2626;
}

.stat-value {
  @apply block text-3xl font-bold mb-2;
  @apply transition-all duration-300;
}

.stat-card.light .stat-value {
  color: #22c55e;
}

.stat-card.medium .stat-value {
  color: #eab308;
}

.stat-card.high .stat-value {
  color: #f97316;
}

.stat-card.overload .stat-value {
  color: #dc2626;
}

.stat-desc {
  @apply text-sm text-gray-500 dark:text-gray-400 font-medium;
}

/* Î∞òÏùëÌòï */
@media (max-width: 1024px) {
  .dual-axis-chart {
    @apply h-80;
  }
  
  .heatmap-chart {
    @apply h-64;
  }
}

@media (max-width: 640px) {
  .chart-info {
    @apply flex-col gap-3;
  }
  
  .load-stats {
    @apply grid-cols-1;
  }
}
</style>