1. frontend 폴더에서 npm run build (Vue.js) 를 dist 배포

2. frontend/dist 폴더를 backend 의 static 으로 복사

3. main.py 코드 수정 

# 실행파일(.exe) 내부의 경로 감지 (PyInstaller 패키징된 경우 `sys._MEIPASS` 사용)
if getattr(sys, 'frozen', False):
    BASE_DIR = sys._MEIPASS  # PyInstaller 실행파일 내부 압축 해제 경로
else:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # 개발 환경에서 실행

# 내부 폴더 경로 설정
STATIC_DIR = os.path.join(BASE_DIR, "static")
ROUTES_DIR = os.path.join(BASE_DIR, "routes")
SETTING_DIR = os.path.join(BASE_DIR, "setting")

app.add_middleware(SessionMiddleware, secret_key="nteksystem2025_sv500")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ✅ Vue.js 개발 서버 주소 (Vite 기본 포트)
    allow_credentials=True,  # ✅ 쿠키를 허용해야 세션이 유지됨!
    allow_methods=["*"],  # 모든 HTTP 메서드 허용
    allow_headers=["*"],  # 모든 HTTP 헤더 허용
)

# 디버깅: 실행파일 내부에서 static 폴더가 있는지 확인
print(f" BASE_DIR: {BASE_DIR}")
print(f" STATIC_DIR: {STATIC_DIR}")

if not os.path.exists(STATIC_DIR):
    print(f"⚠ Warning: Static directory '{STATIC_DIR}' does not exist.")
else:
    print(f"Static directory found: {STATIC_DIR}")
    print(f"Static folder contents: {os.listdir(STATIC_DIR)}")

# FastAPI에서 static 폴더 서빙
app.mount("/static", StaticFiles(directory=STATIC_DIR, html=True), name="static")

@app.get("/")
async def root():
    index_path = os.path.join(STATIC_DIR, "index.html")
    print(f"Serving index.html from: {index_path}")  # 디버깅 로그
    return FileResponse(index_path)


# ✅ Vue Router history 모드 지원 (API 제외 모든 요청을 `index.html`로 리디렉션)
@app.get("/{path:path}")
async def catch_all(path: str):
    print(f" 요청된 경로: {path}")

    # ✅ `/api/...` 요청은 FastAPI에서 기본적으로 처리되도록 예외 처리
    print(f" Vue Router 요청: {path}")
    if path.startswith("api/"):
        pass

    # static_file_path = dist_dir / path

    # # ✅ 정적 파일 요청(`/assets/...`)은 그대로 제공
    # if static_file_path.exists() and static_file_path.is_file():
        # return FileResponse(str(static_file_path))

    # ✅ Vue Router history 모드 지원 → 모든 경로를 `index.html`로 리디렉션
    #print(f"📂 Vue Router 요청: {path} → {index_file}")
    return FileResponse("static/index.html")

def run_server():
    """FastAPI 서버를 실행하는 함수"""
    uvicorn.run(app, host="127.0.0.1", port=4000)

if __name__ == "__main__":
    # FastAPI 서버를 별도의 스레드에서 실행
    server_thread = threading.Thread(target=run_server, daemon=True)
    server_thread.start()

    def shutdown_server():
        print("Shutting down FastAPI server...")
        pid = os.getpid()
        if sys.platform == "win32":
            os.system(f"taskkill /PID {pid} /F")  # Windows 강제 종료
        else:
            os.kill(pid, signal.SIGKILL)  # Linux, Mac 강제 종료

    # 프로그램 종료 시 shutdown_server() 실행
    atexit.register(shutdown_server)

    try:
        while True:
            pass  # 프로그램이 종료될 때까지 대기
    except KeyboardInterrupt:
        shutdown_server()
	
5. 각 라우터에서 설정파일 참조 시, 경로 수정

# 실행파일(.exe) 내부의 경로 감지 (PyInstaller 패키징된 경우 `sys._MEIPASS` 사용)
if getattr(sys, 'frozen', False):
    BASE_DIR = sys._MEIPASS  # PyInstaller 실행파일 내부 압축 해제 경로
else:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # 개발 환경에서 실행

os.makedirs("upload", exist_ok=True)  # 폴더가 없으면 생성
UPLOAD_DIR = os.path.join(BASE_DIR, "upload")
SETTING_DIR = os.path.join(BASE_DIR, "setting")

def getPath(filename):
    read_path = os.path.join(SETTING_DIR, filename)
    return read_path
    

6. PyInstaller 설치 후 빌드하여 하나의 실행파일로 만듬
pyinstaller --onefile --add-data "static;static" --add-data "routes;routes" --add-data "setting;setting" --add-data "upload;upload" --hidden-import=uvicorn --hidden-import=fastapi --hidden-import=bcrypt --hidden-import=influxdb_client --name fastapi_server main_fast.py

pyinstaller --onefile --add-data "config.py;." --add-data "static;static" --add-data "routes;routes" --add-data "setting;setting" --add-data "upload;upload" --hidden-import=uvicorn --hidden-import=fastapi --hidden-import=bcrypt --hidden-import=influxdb_client --name fastapi_server main_fast.py


7. npm 으로 Electron 설치 후, electron 폴더 만든다 다음 실행
npm install electron --save-dev
npm init

8.electron 디렉토리 경로에서 main.js 작성

const { app, BrowserWindow } = require("electron");
const path = require("path");
const { exec, execSync, spawn } = require("child_process");
const axios = require("axios");

let mainWindow;
let backendProcess;

// ✅ FastAPI 서버 실행 여부 확인
const isFastAPIRunning = () => {
    try {
        const result = execSync('tasklist').toString();
        return result.includes("fastapi_server.exe"); // 프로세스 실행 여부 확인
    } catch (error) {
        return false;
    }
};

// ✅ FastAPI 서버 응답 여부 확인
const checkFastAPIServer = async () => {
    try {
        await axios.get("http://127.0.0.1:4000");
        return true;
    } catch (error) {
        return false;
    }
};

// ✅ FastAPI 서버가 완전히 실행될 때까지 대기
const waitForFastAPI = async () => {
    let retries = 10;
    while (retries > 0) {
        if (await checkFastAPIServer()) {
            return true;
        }
        console.log(" Waiting for FastAPI server to start...");
        await new Promise((resolve) => setTimeout(resolve, 1000));
        retries--;
    }
    return false;
};

// ✅ FastAPI 서버 실행 함수
const startFastAPIServer = () => {
    const fastAPIPath = path.join(__dirname, "../dist/fastapi_server.exe");
    console.log(` Starting FastAPI Server: ${fastAPIPath}`);

    // FastAPI 실행 (spawn 사용하여 독립 프로세스로 실행)
    backendProcess = spawn(fastAPIPath, [], {
      detached: false,  // Electron 종료 시 FastAPI도 함께 종료되도록 설정
      stdio: "ignore",  // 콘솔 출력 숨기기
      windowsHide: true // ✅ Windows에서 터미널 창이 뜨지 않도록 설정
  });
    //backendProcess = spawn(fastAPIPath, [], { detached: true, stdio: "ignore" });
    //backendProcess.unref();  // Electron이 종료될 때 자동으로 종료되지 않도록 설정
};

// ✅ FastAPI 서버 종료 함수 (taskkill 실행 전 체크 추가)
const stopFastAPIServer = () => {
  if (isFastAPIRunning()) {
      console.log(" Stopping FastAPI Server...");

      try {
          // Windows에서는 `taskkill`을 사용하여 강제 종료
          if (process.platform === "win32") {
              execSync("taskkill /IM fastapi_server.exe /F", { stdio: "ignore" });
              console.log(" FastAPI Server stopped.");
          } else {
              backendProcess.kill();  // 일반적인 종료 (MacOS, Linux)
          }
      } catch (error) {
          console.error(` Error stopping FastAPI: ${error.message}`);
      }
  } else {
      console.log("FastAPI is not running. No need to stop.");
  }
};

// ✅ Electron 앱 시작
app.whenReady().then(async () => {
    console.log("🚀 Starting Electron App...");

    // FastAPI 서버 실행 여부 확인 후 시작
    if (!isFastAPIRunning()) {
        console.log(" FastAPI is not running. Starting the server...");
        startFastAPIServer();
    } else {
        console.log(" FastAPI server is already running. Skipping execution.");
    }

    // FastAPI가 완전히 실행될 때까지 대기
    const fastAPIReady = await waitForFastAPI();

    if (!fastAPIReady) {
        console.error(" FastAPI server did not start. Exiting Electron...");
        app.quit();
        return;
    }

    console.log(" FastAPI server is running! Opening Electron window.");
    createWindow();
});

// ✅ Electron 창 생성
function createWindow() {
    mainWindow = new BrowserWindow({
        width: 1200,
        height: 800,
        webPreferences: {
            nodeIntegration: true,
        },
    });

    mainWindow.loadURL("http://127.0.0.1:4000");

    mainWindow.on("closed", () => {
        mainWindow = null;
        stopFastAPIServer(); // 창 닫힐 때 FastAPI 종료
    });
}

// ✅ Electron 앱 종료 시 FastAPI 서버도 종료
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        stopFastAPIServer();
        app.quit();
    }
});

// ✅ MacOS에서 창을 닫았을 때 FastAPI가 남아있지 않도록 처리
app.on("before-quit", () => {
    stopFastAPIServer();
});


9. package.json 에 다음항목 추가

  "scripts": {
    "start": "electron .",
    "build": "electron-builder"
  },
  "build": {
    "appId": "com.nteksystem.SV500Configurator",
    "productName": "SV500Configurator",
    "win": {
      "target": "portable",
      "icon": "configicon.ico",
      "signAndEditExecutable": false,
      "sign": false  
    },
    "files": [
      "**/*",
      "!node_modules/electron", 
      "!node_modules/.bin",
      "!dist",
      "!*.map",
      {
        "from": "../dist/fastapi_server.exe",
        "to": "resources/fastapi_server.exe"
      }
    ],
    "directories": {
      "output": "dist"
    }
  },
10. electron-builder.json 파일 생성

{
  "win": {
    "target": ["portable"]
  }
}


11. 빌드 : npx electron-builder --win portable --publish never --config electron-builder.json

12. fastapi_server.exe 파일을 electron/dist 폴더에 복사